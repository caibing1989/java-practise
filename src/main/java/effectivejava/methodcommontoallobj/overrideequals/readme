覆盖equals方法看起来似乎很简单，但是有许多覆盖方式会导致错误，并且后果非常严重。
最容易避免这类问题的办法就是不覆盖equals方法，在这种情况下，类的每个实例都只与它自身相等。
如果满足了以下任何一个条件，这就正是所期望的结果：
类的每个实例本质上都是唯一的。对于代表活动实体而不是值（value）的类来说确实如此，例如Thread
类没有必要提供"逻辑相等"（logical equality）的测试功能
超类已经覆盖了equals，超类的行为对于这个类也是合适的
类是私有的，或者是包级私有的，可以确定它的equals方法永远不会被调用


那么，什么时候应该覆盖equals方法呢？
如果类具有自己特有的"逻辑相等"（logical equality）概念，而且超类还没有覆盖equals。
这通常属于"值类"（value class）的情况
程序员在利用equals方法类比较值对象的引用时，希望知道它们在逻辑上是否相等，而不是想了解它们是否指向同一个对象。
为了满足程序员的要求，不仅必须覆盖equals方法，而且这样做也使得这个类的实例可以被用作映射表（map）的键（key），使映射表现出预期的行为


在覆盖equals方法的时候，必须要遵守它的通用约定：
自反性（reflexive）：对于任何非null的引用值x，x.equals(x)必须返回true。
对称性（symmetric）：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)必须返回true