1、jvm调优什么？
内存总大小、新生代、存活区和老年代大小、垃圾收集算法和垃圾收集器代选择、控制gc停顿时间和停顿次数
通过观察虚拟机中内存大小的走势， 内存对象的热点统计、以及相应相应线程等 来辅助解决内存泄漏问题，优化代码
线程方面的死锁检查
线程方面的dump线程详细信息，查看线程内部运行情况，查找竞争线程，对资源的争用会使整体应用变慢，辅助代码优化
cpu热点，查看哪些热点包、热点类、热点方法执行占用了大量的cpu资源，辅助代码优化

2、如何调优？
监控jvm的状态，主要是内存、线程、代码、I/O部分
利用jmc的飞行记录和visualvm进行实时监控
分析结果判断，判断是否需要优化
调整，垃圾回收算法（垃圾收集器选择和垃圾回收算法的参数配置）和内存分配，修改代码
不断的重复监控、分析和调整，直到找到优化的平衡点（各方都可以接受），优化本身就是无底洞

3、jvm调优的目标？
gc的时间要足够的小，单次gc的时间要小，总的gc时间要小
gc的次数要足够的小
将转移到老年代的对象数量和大小降低到最小
减少full gc的执行时间
发生full gc的间隔足够的长

4、常见的调优策略？
减少创建对象的数量，尽量复用对象
减少使用全局变量和大对象
调整新生代、存活区、和老年代的大小到最合适
选择合适的gc收集器，并设置合理的参数

5、jvm调优冷思考
多数的java应用不需要在服务器上进行gc优化，除了一些内存方面的配置，比如总大小、新生代
多数导致gc的java应用，都不是参数设置错误，而是代码问题
在应用上线之前，应该考虑将服务器jvm参数设置到最优（最适合）
jvm优化是最后不得已才采用的手段
在实际情况中，通过分析jvm情况去优化代码比优化jvm本身要多得多

6、什么情况下不建议优化？
minorGc的时间不到50毫秒
minorGc执行频率不频繁，约10秒一次
fullGc执行时长不到1秒
fullGc执行频率不高，不低于10分钟一次

7、jvm的调优经验？
要想gc时间小，必须要一个更小的堆，要想gc次数少，必须要有个更大的堆，两者只能取其平衡
-Xms、-Xmx一般设定为相同的值，防止垃圾收集器在最大值和最小值来回收缩
新生代和老年代 设置为2或者1
合理设置新生代和老年代的大小
新生代设置越大，minorGc的频率越小，相对应的minorGc的时间更长，这个需要监控一段时间虚拟机的运行情况
如果存在较多的临时对象，应该选择更大的新生代；如果存在较多的持久对象，应该选择更多的老年代空间，本着full gc尽量少的原则，让老年代尽量缓存对象，默认2就是这个道理
通过一段时间观察，看其在峰值的时候老年代占用多少内存，在不影响full gc的前提下，根据实际情况增加新生代的空间，但是需要给老年代1/3的增长buffer
线程堆栈设置，默认是1m，其实默认值有点偏大，256k就足够了，但是需要观察，不能拍脑袋

8、内存泄漏的调优
内存泄漏导致系统崩溃前的现象，比如每次垃圾回收的时间越来越长，full gc也延长到好几秒
full gc的次数越来越多，最频繁的时间间隔不到1分钟
老年代的内存越来越大，同时每次full gc之后，老年代没有内存释放
堆栈溢出的情况，会抛出stackOverFlowError