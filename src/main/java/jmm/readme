1、jmm是什么？
jmm是一个规范，目的是解决多线程安全问题

2、什么是重排序？
实际执行顺序与代码描述的顺序 不一致

3、重排序的好处
重排序明显提高了处理速度

4、重排序的3种情况
编译器中的重排序
cpu中的重排序
多线程内存可见性问题导致的重排序

5、什么是可见性
确实存在，但是其它线程看不见

6、为什么会有可见性问题
cpu有多级缓存，同时每个核心对应的高速缓存又是相互隔离的，读取的数据可能会过期，所以可见性问题不是由多核引起的，而是由多层缓存引起的

7、cpu为什么会有多级缓存？
因为需要考虑读取速度，cpu不能直接和主内存直接打交道，而是直接和高速缓存打交道

7、主内存和本地内存是什么？
jmm将寄存器、三级缓存、ram总共5层抽象成了2层，工作内存和主内存，既便于开发人员编程，又兼顾计算机的高速缓存特性

8、jmm规定的主内存和本地内存之间的关系是？
所有的变量都存在主内存中，本地内存里面都是复制的拷贝，每个线程都有自己独立的本地内存，线程只能直接操作本地内存，无法操作主内存中的变量，这就导致了可见性问题

9、happens-before原则，什么是happens-before
如果一个操作happens-before于另一个操作，那第一个操作对于第二操作是可见的

10、happens-before规则有哪些？
volatile synchronized

11、jmm是如何解决可见性问题的

12、volatile的两个作用
可见性和禁止指令重排

13、volatile的使用场合
已经具备原子性，加上volatile后 就保证了可见性

14、volatile不适用
不适用不具备原子性的并发，容易造成线程安全问题

15、volatile和synchronized对比
可以做到轻量同步，做不到原子同步，除非已经有其它操作保证了原子性，volatile的读写操作是无锁的，没有办法提供原子性和互斥性，volatile只能用于某个属性，不能用于代码块上或者方法上

16、哪些措施可以保证可见性
volatile、synchronized、lock、join、start可以保证可见性

17、什么是原子性？
一系列操作，要不全部执行完毕，要不全部都不执行，不会出现执行一半的情况，一系列操作是不可分割的

18、原子操作有哪些？
除了long、double等基本类型的赋值操作，以及所有引用的赋值操作，atomic下面所有的类都是原子类

19、long和double的原子性
因为它们是64位的，在32位的jvm上，分成2个32位的操作，所以不是原子性的，可以通过添加volatile或者其它同步方式来保证其原子性
在64位的jvm上，就是原子的
实际生产环境中，商用的jvm都处理了long、double的问题

20、单例模式的8种写法，单例和并发的关系

21、单例模式的作用，为什么需要单例模式？
节省io、内存和计算
方便管理，例如工具类
保证结果正确，例如单例计数器

22、单例模式的适用场景
1、无状态的工具类，例如日志工具类、日期工具类
2、全局信息类