1、写一个必然死锁的例子

2、满足死锁的4个必要条件？

3、如何定位死锁？

4、如何解决死锁？

5、实际工程实践中如何避免死锁？
设置超时时间，例如tryLock(long timeout, TimeUnit unit)
多使用并发类，而不是自己设计锁
尽量降低锁的粒度：用不同的锁，而不是一个锁
避免锁的嵌套

6、死锁的兄弟，活锁、饥饿和死锁的异同？

7、什么是死锁？
死锁发生在并发中，两个线程或多个线程互相持有对方的所需要的互斥资源，形成环路，又不主动释放，且无外界主动干预，最后导致程序进入无穷的阻塞

8、死锁的影响
死锁的影响在不同的系统中不一样，数据库中的死锁 会被监测到，并干预，jvm中则不具备主动处理的能力

9、死锁有哪些危害


10、发生死锁的4个必要条件
资源互斥条件、请求与保持条件、循环等待条
件、不剥夺条件
11、死锁常见修复策略
避免策略、检测和恢复策略
思路，避免相反的获取锁的顺序

12、哲学家问题解决
服务员解决
改变一个哲学家的刀叉顺序
餐票
领导调节

13、如何解决活锁问题
加入随机因素

14、消息队列失败了，该怎么处理？
放到队尾部，限制次数，最后放到数据库中，定时触发

15、什么是饥饿？
线程一直需要某些资源（一般是指cpu资源），却一直得不到