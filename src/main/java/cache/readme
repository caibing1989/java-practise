1、什么是缓存？
如今缓存的概念已被扩充，不仅在CPU和主内存之间有Cache，而且在内存和硬盘之间也有Cache（磁盘缓存），
乃至在硬盘与网络之间也有某种意义上的Cache──称为Internet临时文件夹或网络内容缓存等。
凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为Cache

2、缓存的分类？
CDN
反向代理
本地缓存
分布式缓存

3、CDN？
即内容分发网络（Content Delivery Network），部署在距离终端用户最近的网络服务商，用户的网络请求总是先到达他的网络服务商哪里，
在这里缓存网站的一些静态资源（较少变化的数据），可以就近以最快速度返回给用户，如视频网站和门户网站会将用户访问量最大的热点内容缓存在CDN

4、反向代理？
反向代理属于网站前端架构的一部分，部署在网站的前端，当用户请求到达网站的数据中心时，
最先访问到就是反向代理服务器，这里缓存网站的静态资源（如js，css，图片），无需将请求继续转发给应用服务器就能返回给用户

5、本地缓存？
在应用服务器本地缓存着热点数据，应用程序可以在本机内存中直接访问数据，而无需访问数据库。
如 Spring 使用 ConcurrentHashMap 缓存了单例 Bean。
还比如JVM使用堆内存缓存Java对象。

6、分布式缓存？
大型网站的数据量非常庞大，即使只缓存一小部分，需要的内存空间也不是单机能承受的，所以除了本地缓存，还需要分布式缓存，
将数据缓存在一个专门的分布式缓存集群中，应用程序通过网络通信访问缓存数据。
如 Pigeon 的注册中心基于 Zookeeper 存储了服务提供者

7、缓存命中率？
缓存命中率=从缓存中读取次数/总读取次数。命中率越高越好。这是一个非常重要的监控指标

8、缓存的回收策略？
基于空间
指缓存设置了存储空间，如设置为 100MB，当达到存储空间上限时，按照一定的策略移除数据。
以 JVM 为例，当 Eden 区空间不足时，触发 MinorGC 回收内存；当老年代空间不足时，触发 MajorGC 回收内存。
基于容量
指缓存设置了最大大小，当缓存的条目超过最大大小时，按照一定的策略移除数据。
如 Gauva Cache 可以通过 maximumSize 参数设置缓存容量，当超出 maximumSize 时，按照 LRU 算法进行缓存回收。
基于时间
TTL（Time To Live）：存活期，即缓存数据从创建开始直到到期的一个时间段（不管在这个时间段内有没有被访问，缓存数据都将过期）。
TTI（Time To Idle）：空闲期，即缓存数据多久没被访问后移除缓存的时间。

9、回收算法？
FIFO（First In First Out）：先进先出算法，即先放入缓存的先被移除。
LRU（Least Recently Used）：最近最少使用算法，使用时间距离现在最久的那个被移除。
LFU（Least Frequently Used）：最不常用算法，一定时间段内使用次数（频率）最少的那个被移除。

10、缓存的更新策略
Cache-Aside
该模式对缓存的关注点主要在于业务代码，即缓存的更新，删除与数据库的操作，以及他们之间的先后顺序在业务代码中实现。
读操作：
先读缓存，缓存命中，则直接返回
缓存未命中，则回源到数据库获取源数据
将数据重新放入缓存，下次即可从缓存中获取数据
写操作：
有两个方案
先操作缓存，再操作数据库
先操作数据库，再操作缓存
本质上这是一个分布式事务问题，要保证原子性十分困难。假如出现一个操作成功，一个操作失败，哪个方案更好呢？
方案一
操作缓存又分为两种情况：set 和 delete。
假如先 set 缓存成功，再写数据库失败，这会导致数据不一致。
假如先 delete 缓存成功，再写数据库失败，这不会导致数据不一致，仅仅会多一次缓存 miss 的成本
方案二
假如先操作数据库成功，再操作（delete或set）缓存失败，这会导致数据不一致，程序读到旧的缓存数据！
因此可以得出结论，
对于读请求，先读缓存，如果未命中，再读数据库，并将数据 set 回缓存。
对于写请求，先删缓存，再写数据库。
Cache-Aside 需要业务代码维护两个数据源，一个是缓存，一个是数据库，比较繁琐。而 Read/Write-through 就是把对数据库的操作让缓存来代理了。

Cache-As-SoR
Read-Through
Read-Through 也是在查询操作中更新缓存，和 Cache-Aside 相比，唯一的区别就是，当缓存失效的时候（过期或LRU换出），
Cache-Aside 是由业务代码负责把数据加载入缓存，而 Read-Through 则用缓存服务自己来加载，从而对业务代码是透明的
Write-Through
Write-Through 和 Read-Through类似，只不过是在更新数据时发生。
当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由缓存自己同步更新数据库。
Write-Behind
Write-Behind 也叫 Write-Back。就是在更新数据的时候，只更新缓存，不同步更新数据库，而是异步地更新数据库（可以实现批量写、合并写、延时写）。