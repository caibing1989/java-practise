1、为什么需要lock？为什么synchronized不够用？
synchronized效率低，不能设置超时，不能中断试图获取锁的过程
synchronized不够灵活，读写锁比较灵活
无法知道synchronized是否成功获取到了锁

2、Lock中有哪些主要的方法？
lock()、tryLock()、tryLock(time)、lockInterruptibly

lock不会像synchronized那样，在发生异常时，主动自动释放锁，所以需要在finally中释放锁

lock一旦遇到死锁，lock就会陷入永久等待

3、锁有哪些分类？
乐观锁、悲观锁
可重入锁、不可重入锁
公平锁、非公平锁
共享锁、排他锁 也叫 读写锁

4、悲观锁 也称互斥同步锁
阻塞、唤醒带来的性能问题
永久阻塞问题
例如 synchronized和lock

5、乐观锁也称非户次同步锁
最大的特点是，它不会去锁住被操作的对象，第二它会去更新，更新之前看看有没有被其它人操作过
遇到问题再处理，处理的方式有报错、放弃、重试
一般来锁乐观锁是通过cas算法实现的

6、读写锁的插队策略
公平锁：不允许插队，只要队列中有，就去等待
非公平锁：写锁可以插队，读锁会去看头节点是不是写锁，如果是写锁就不插队

7、写锁可以降级，读锁不能升级，读锁升级容易造成死锁（都拿着读锁，想获取写锁）

8、自旋锁和阻塞锁

9、为什么需要自旋锁？
因为每次从阻塞唤醒的时间和开销有可能比执行时耗费的资源还要多，在并发不那么高，执行时间不怎么长的情况，自旋锁可能是一种合适的选择

10、自旋锁的缺点？
自旋的时候要消耗cpu，不适合并发比较高，或者临界区比较长的情况

11、锁优化有哪些？
jvm对锁的优化：自旋锁与自适应、锁消除、锁粗化
个人写代码的优化：缩小同步代码块、尽量不要锁住方法、减少请求锁的次数（比如打印日志）、避免人为制造热点（比如hashmap中的size方法）、锁中不要再包含锁、选择合适的锁分类（读写锁）

